#!/usr/bin/env python3

import argparse
import cv2
import numpy as np
import math
import enum
from collections import namedtuple


def parse_arguments():
    parser = argparse.ArgumentParser(
        description='Scan colours from image of Rubik\'s Cube face'
    )
    parser.add_argument('image', help='Image file to scan')
    parser.add_argument('--edges', help='File to save edges image to')
    parser.add_argument('--lines', help='File to save lines image to')
    parser.add_argument(
        '--orth',
        help='File to save orthogonal lines image to'
    )
    parser.add_argument('--comb', help='File to save combined lines image to')
    parser.add_argument('--clines', help='File to save centre lines image to')
    parser.add_argument(
        '--cpoints',
        help='File to save centre points image to'
    )

    return parser.parse_args()


IntermediateImageSet = namedtuple(
    "IntermediateImageSet",
    ["edges", "lines", "orthogonalLines", "combinedLines", "centreLines",
     "centrePoints"]
)


def scan_cube(cubeImage):
    """Scan the given cube image and return the colours of the cube face.

    Returns tuple (colours, intermediate images) where colours is a tuple
    of scanned colours and intermediate images are images generated through
    the scanning process to be used for debugging.
    """
    edgeImage = _detect_edges(cubeImage)
    lines = _detect_lines(edgeImage)
    orthogonalLines = _horizontal_and_vertical_lines(lines)

    combinedLines = _combine_lines(orthogonalLines)
    if len(combinedLines) != 8:
        return None

    centreLines = _find_centre_lines(combinedLines)
    if centreLines is None:
        return None

    centrePoints = _find_centres(centreLines)

    squareColours = _square_colours(cubeImage, centrePoints)
    rubiksColours = [_to_rubiks_colour(colour) for colour in squareColours]

    intermediate_images = IntermediateImageSet(
        edges=edgeImage,
        lines=_draw_lines(cubeImage, lines),
        orthogonalLines=_draw_lines(cubeImage, orthogonalLines),
        combinedLines=_draw_lines(cubeImage, combinedLines),
        centreLines=_draw_lines(
            cubeImage,
            (line for centreLineGroup in centreLines for line in centreLineGroup)
        ),
        centrePoints=_draw_points(cubeImage, centrePoints)
    )

    return rubiksColours, intermediate_images


def _detect_edges(image):
    """Detects edges in the given image using Canny edge detection."""
    grayImage = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurredGrayImage = cv2.GaussianBlur(grayImage, (5, 5), 0)
    edgeImage = cv2.Canny(blurredGrayImage, 0, 50)

    return edgeImage


def _detect_lines(edgeImage, threshold=125):
    """Detects lines in the given edge image using the Hough transform."""
    lines = cv2.HoughLines(edgeImage, 1, np.pi/180, threshold)
    # Change line representation from [(rho, theta)] to just (rho, theta)
    lines = [line[0] for line in lines]

    # Stop rho from wrapping round from positive to negative and theta from
    # wrapping round from pi to 0. This ensures similar lines have similar
    # values when compared.
    lines = [
        (rho, theta) if rho >= 0 else (-rho, theta - np.pi)
        for (rho, theta) in lines
    ]

    return lines


def _draw_lines(image, lines):
    """Returns a copy of the image with the given lines drawn on."""
    imageCopy = image.copy()

    for rho, theta in lines:
        a = np.cos(theta)
        b = np.sin(theta)
        x0 = a*rho
        y0 = b*rho
        x1 = int(x0 + 1000*(-b))
        y1 = int(y0 + 1000*a)
        x2 = int(x0 - 1000*(-b))
        y2 = int(y0 - 1000*a)

        cv2.line(imageCopy, (x1, y1), (x2, y2), (0, 0, 255), 2)

    return imageCopy


def _is_horizontal(line):
    """Returns True if line is within 1/36pi of horizontal."""
    _, theta = line
    return theta > np.pi*17/36 and theta < np.pi*19/36


def _is_vertical(line):
    """Returns True if line is within 1/36pi of vertical."""
    _, theta = line
    return theta > -np.pi/36 and theta < np.pi/36


def _horizontal_and_vertical_lines(lines):
    """Returns only horizontal and vertical lines of the lines given."""
    return [
        line for line in lines
        if _is_horizontal(line) or _is_vertical(line)
    ]


def _similar(line1, line2, rhoThreshold=50, thetaThreshold=np.pi/18):
    """Returns True if the two lines are similar enough, False otherwise."""
    rho1, theta1 = line1
    rho2, theta2 = line2

    if abs(rho1 - rho2) > rhoThreshold:
        return False

    if abs(theta1 - theta2) > thetaThreshold:
        return False

    return True


def _average_line(lines):
    """Combines a group of lines and returns their average."""
    averageRho = sum(rho for rho, _ in lines) / len(lines)
    averageTheta = sum(theta for _, theta in lines) / len(lines)
    return averageRho, averageTheta


def _combine_lines(lines):
    """Combines lines that are similar to one another."""
    similarLineGroups = [
        # Convert to tuple to be hashable for set below
        tuple([line for line in lines if _similar(line, originalLine)])
        for originalLine in lines
    ]

    uniqueSimilarLineGroups = set(similarLineGroups)

    combinedLines = {
        _average_line(similarLines)
        for similarLines in uniqueSimilarLineGroups
    }

    return combinedLines


def _identify_horizontal_lines(lines):
    """Identifies the horizontal lines and returns them from top to bottom."""
    horizontalLines = [line for line in lines if _is_horizontal(line)]
    # Rho shows how far away from origin therefore position in top to bottom
    horizontalLines.sort(key=lambda line: line[0])
    return tuple(horizontalLines)


def _identify_vertical_lines(lines):
    """Identifies the vertical lines and returns them from left to right."""
    verticalLines = [line for line in lines if _is_vertical(line)]
    # Rho shows how far away from origin therefore position in left to right
    verticalLines.sort(key=lambda line: line[0])
    return tuple(verticalLines)


def _find_centre_lines(lines):
    """Finds the lines passing through the centre of each square"""
    # Number identifies position from 1 to 4 in top to bottom ordering
    horizontalLines = _identify_horizontal_lines(lines)
    if len(horizontalLines) != 4:
        return None
    hor1, hor2, hor3, hor4 = horizontalLines

    # Number identifies position from 1 to 4 in left to right ordering
    verticalLines = _identify_vertical_lines(lines)
    if len(verticalLines) != 4:
        return None
    vert1, vert2, vert3, vert4 = verticalLines

    topCentreHorizontal = _average_line([hor1, hor2])
    middleCentreHorizontal = _average_line([hor2, hor3])
    bottomCentreHorizontal = _average_line([hor3, hor4])

    leftCentreVertical = _average_line([vert1, vert2])
    middleCentreVertical = _average_line([vert2, vert3])
    rightCentreVertical = _average_line([vert3, vert4])

    return (
        (topCentreHorizontal, middleCentreHorizontal, bottomCentreHorizontal),
        (leftCentreVertical, middleCentreVertical, rightCentreVertical)
    )


def _intersection(line1, line2):
    """Finds the (x, y) point where two lines intersect."""
    rho1, theta1 = line1
    rho2, theta2 = line2

    cosTheta1 = math.cos(theta1)
    sinTheta1 = math.sin(theta1)
    cosTheta2 = math.cos(theta2)
    sinTheta2 = math.sin(theta2)

    det = cosTheta1*sinTheta2 - sinTheta1*cosTheta2

    # det is None when lines are parallel
    if det is None:
        return None

    x = (sinTheta2*rho1 - sinTheta1*rho2) / det
    y = (cosTheta1*rho2 - cosTheta2*rho1) / det

    return (x, y)


def _find_centres(centreLines):
    horizontalLines, verticalLines = centreLines

    topLeftCentre = _intersection(horizontalLines[0], verticalLines[0])
    topMiddleCentre = _intersection(horizontalLines[0], verticalLines[1])
    topRightCentre = _intersection(horizontalLines[0], verticalLines[2])

    middleLeftCentre = _intersection(horizontalLines[1], verticalLines[0])
    middleCentre = _intersection(horizontalLines[1], verticalLines[1])
    middleRightCentre = _intersection(horizontalLines[1], verticalLines[2])

    bottomLeftCentre = _intersection(horizontalLines[2], verticalLines[0])
    bottomMiddleCentre = _intersection(horizontalLines[2], verticalLines[1])
    bottomRightCentre = _intersection(horizontalLines[2], verticalLines[2])

    return (
        topLeftCentre, topMiddleCentre, topRightCentre,
        middleLeftCentre, middleCentre, middleRightCentre,
        bottomLeftCentre, bottomMiddleCentre, bottomRightCentre
    )


def _draw_points(image, points):
    """Returns a copy of the image with the given points drawn on."""
    imageCopy = image.copy()
    for x, y in points:
        cv2.circle(imageCopy, (int(x), int(y)), 3, (255, 0, 255), -1)

    return imageCopy


def _colours_around_centre(image, centrePoint, offset):
    """Returns a list of colours in a square around a centre point"""
    centreX, centreY = centrePoint
    leftX = int(centreX) - offset
    rightX = int(centreX) + offset
    topY = int(centreY) - offset
    bottomY = int(centreY) + offset

    pixelColours = [
        image[y][x]
        for x in range(leftX, rightX + 1)
        for y in range(topY, bottomY + 1)
    ]

    return pixelColours


def _average_colour(colours):
    """Find the average of a list of colours."""
    bAverage = math.sqrt(sum(b**2 for b, _, _ in colours) / len(colours))
    gAverage = math.sqrt(sum(g**2 for _, g, _ in colours) / len(colours))
    rAverage = math.sqrt(sum(r**2 for _, _, r in colours) / len(colours))

    return (bAverage, gAverage, rAverage)


def _square_colours(image, centrePoints, offset=20):
    """Finds colour of each square using square around its centre point."""
    squareColours = tuple(
        _average_colour(_colours_around_centre(image, centrePoint, offset))
        for centrePoint in centrePoints
    )

    return squareColours


def _colour_similarity(colour1, colour2):
    """Returns the similarity between the colours from 0 (none) to 100 (the
    same).
    """
    b1, g1, r1 = colour1
    b2, g2, r2 = colour2

    diffBlue = abs(b1 - b2)
    diffGreen = abs(g1 - g2)
    diffRed = abs(r1 - r2)

    difference = (diffBlue + diffGreen + diffRed) / 3 / 255 * 100
    similarity = 100 - difference

    return similarity


def _to_rubiks_colour(colour):
    """Returns the nearest rubiks cube colour to the given colour."""
    rubiksColours = [
        ('white', (255., 255., 255.)),
        ('green', (72., 155., 0.)),
        ('red', (52., 18., 183.)),
        ('blue', (173., 70., 0.)),
        ('orange', (0., 88., 255.)),
        ('yellow', (0., 213., 255.))
    ]

    similarities = [
        (rubiksColourName, _colour_similarity(colour, rubiksColour))
        for (rubiksColourName, rubiksColour) in rubiksColours
    ]

    similarities.sort(key=lambda similarity: similarity[1], reverse=True)

    return similarities[0][0]


if __name__ == '__main__':
    args = parse_arguments()

    colours, intermediate_images = scan_cube(cv2.imread(args.image))

    if colours is not None:
        print('+--------+--------+--------+')
        print(f'|{colours[0]:^8}|{colours[1]:^8}|{colours[2]:^8}|')
        print('+--------+--------+--------+')
        print(f'|{colours[3]:^8}|{colours[4]:^8}|{colours[5]:^8}|')
        print('+--------+--------+--------+')
        print(f'|{colours[6]:^8}|{colours[7]:^8}|{colours[8]:^8}|')
        print('+--------+--------+--------+')
    else:
        print('Scan failed')

    if args.edges is not None:
        cv2.imwrite(args.edges, intermediate_images.edges)
    if args.lines is not None:
        cv2.imwrite(args.lines, intermediate_images.lines)
    if args.orth is not None:
        cv2.imwrite(args.orth, intermediate_images.orthogonalLines)
    if args.comb is not None:
        cv2.imwrite(args.comb, intermediate_images.combinedLines)
    if args.clines is not None:
        cv2.imwrite(args.clines, intermediate_images.centreLines)
    if args.cpoints is not None:
        cv2.imwrite(args.cpoints, intermediate_images.centrePoints)
