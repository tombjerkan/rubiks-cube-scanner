#!/usr/bin/env python3

import argparse
import cv2
import numpy as np
import math
import enum


def scan_cube(
        cubeImage,
        edgeImageFile=None,
        linesImageFile=None,
        orthogonalLinesImageFile=None,
        combinedLinesImageFile=None,
        centreLinesImageFile=None,
        centrePointsImageFile=None):
    """Scan the given cube image and return the colours of the cube face.

    Returns None if cube face could not be scanned.
    Saves the intermediate edge image generated to the filename given.
    Saves the intermediate lines image generated to the filename given.
    Saves the intermediate orthogonal lines image generated to the filename
    given.
    Saves the intermediate combined lines image generated to the filename
    given.
    """
    edgeImage = _detect_edges(cubeImage)
    if edgeImageFile is not None:
        cv2.imwrite(edgeImageFile, edgeImage)

    lines = _detect_lines(edgeImage)
    if linesImageFile is not None:
        linesImage = _draw_lines(cubeImage, lines)
        cv2.imwrite(linesImageFile, linesImage)

    orthogonalLines = _horizontal_and_vertical_lines(lines)
    if orthogonalLinesImageFile is not None:
        orthogonalLinesImage = _draw_lines(cubeImage, orthogonalLines)
        cv2.imwrite(orthogonalLinesImageFile, orthogonalLinesImage)

    combinedLines = _combine_lines(orthogonalLines)
    if combinedLinesImageFile is not None:
        combinedLinesImage = _draw_lines(cubeImage, combinedLines)
        cv2.imwrite(combinedLinesImageFile, combinedLinesImage)

    if len(combinedLines) != 8:
        return None

    centreLines = _find_centre_lines(combinedLines)
    if centreLinesImageFile is not None:
        centreLinesImage = _draw_lines(cubeImage, [
            line for centreLineGroup in centreLines for line in centreLineGroup
        ])
        cv2.imwrite(centreLinesImageFile, centreLinesImage)

    if centreLines is None:
        return None

    centrePoints = _find_centres(centreLines)
    if centrePointsImageFile is not None:
        centrePointsImage = _draw_points(cubeImage, centrePoints)
        cv2.imwrite(centrePointsImageFile, centrePointsImage)

    squareColours = _square_colours(cubeImage, centrePoints)
    rubiksColours = [_to_rubiks_colour(colour) for colour in squareColours]

    return rubiksColours


def _detect_edges(image):
    """Detects edges in the given image using Canny edge detection."""
    grayImage = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurredGrayImage = cv2.GaussianBlur(grayImage, (5, 5), 0)
    edgeImage = cv2.Canny(blurredGrayImage, 0, 50)

    return edgeImage


def _detect_lines(edgeImage, threshold=125):
    """Detects lines in the given edge image using the Hough transform."""
    lines = cv2.HoughLines(edgeImage, 1, np.pi/180, threshold)
    # Change line representation from [(rho, theta)] to just (rho, theta)
    lines = [line[0] for line in lines]

    # Stop rho from wrapping round from positive to negative and theta from
    # wrapping round from pi to 0. This ensures similar lines have similar
    # values when compared.
    lines = [
        (rho, theta) if rho >= 0 else (-rho, theta - np.pi)
        for (rho, theta) in lines
    ]

    return lines


def _draw_lines(image, lines):
    """Returns a copy of the image with the given lines drawn on."""
    imageCopy = image.copy()

    for rho, theta in lines:
        a = np.cos(theta)
        b = np.sin(theta)
        x0 = a*rho
        y0 = b*rho
        x1 = int(x0 + 1000*(-b))
        y1 = int(y0 + 1000*a)
        x2 = int(x0 - 1000*(-b))
        y2 = int(y0 - 1000*a)

        cv2.line(imageCopy, (x1, y1), (x2, y2), (0, 0, 255), 2)

    return imageCopy


def _is_horizontal(line):
    """Returns True if line is within 1/36pi of horizontal."""
    _, theta = line
    return theta > np.pi*17/36 and theta < np.pi*19/36


def _is_vertical(line):
    """Returns True if line is within 1/36pi of vertical."""
    _, theta = line
    return theta > -np.pi/36 and theta < np.pi/36


def _horizontal_and_vertical_lines(lines):
    """Returns only horizontal and vertical lines of the lines given."""
    return [
        line for line in lines
        if _is_horizontal(line) or _is_vertical(line)
    ]


def _similar(line1, line2, rhoThreshold=50, thetaThreshold=np.pi/18):
    """Returns True if the two lines are similar enough, False otherwise."""
    rho1, theta1 = line1
    rho2, theta2 = line2

    if abs(rho1 - rho2) > rhoThreshold:
        return False

    if abs(theta1 - theta2) > thetaThreshold:
        return False

    return True


def _average_line(lines):
    """Combines a group of lines and returns their average."""
    averageRho = sum(rho for rho, _ in lines) / len(lines)
    averageTheta = sum(theta for _, theta in lines) / len(lines)
    return averageRho, averageTheta


def _combine_lines(lines):
    """Combines lines that are similar to one another."""
    similarLineGroups = [
        # Convert to tuple to be hashable for set below
        tuple([line for line in lines if _similar(line, originalLine)])
        for originalLine in lines
    ]

    uniqueSimilarLineGroups = set(similarLineGroups)

    combinedLines = {
        _average_line(similarLines)
        for similarLines in uniqueSimilarLineGroups
    }

    return combinedLines


def _identify_horizontal_lines(lines):
    """Identifies the horizontal lines and returns them from top to bottom."""
    horizontalLines = [line for line in lines if _is_horizontal(line)]
    # Rho shows how far away from origin therefore position in top to bottom
    horizontalLines.sort(key=lambda line: line[0])
    return tuple(horizontalLines)


def _identify_vertical_lines(lines):
    """Identifies the vertical lines and returns them from left to right."""
    verticalLines = [line for line in lines if _is_vertical(line)]
    # Rho shows how far away from origin therefore position in left to right
    verticalLines.sort(key=lambda line: line[0])
    return tuple(verticalLines)


def _find_centre_lines(lines):
    """Finds the lines passing through the centre of each square"""
    # Number identifies position from 1 to 4 in top to bottom ordering
    horizontalLines = _identify_horizontal_lines(lines)
    if len(horizontalLines) != 4:
        return None
    hor1, hor2, hor3, hor4 = horizontalLines

    # Number identifies position from 1 to 4 in left to right ordering
    verticalLines = _identify_vertical_lines(lines)
    if len(verticalLines) != 4:
        return None
    vert1, vert2, vert3, vert4 = verticalLines

    topCentreHorizontal = _average_line([hor1, hor2])
    middleCentreHorizontal = _average_line([hor2, hor3])
    bottomCentreHorizontal = _average_line([hor3, hor4])

    leftCentreVertical = _average_line([vert1, vert2])
    middleCentreVertical = _average_line([vert2, vert3])
    rightCentreVertical = _average_line([vert3, vert4])

    return (
        (topCentreHorizontal, middleCentreHorizontal, bottomCentreHorizontal),
        (leftCentreVertical, middleCentreVertical, rightCentreVertical)
    )


def _intersection(line1, line2):
    """Finds the (x, y) point where two lines intersect."""
    rho1, theta1 = line1
    rho2, theta2 = line2

    cosTheta1 = math.cos(theta1)
    sinTheta1 = math.sin(theta1)
    cosTheta2 = math.cos(theta2)
    sinTheta2 = math.sin(theta2)

    det = cosTheta1*sinTheta2 - sinTheta1*cosTheta2

    # det is None when lines are parallel
    if det is None:
        return None

    x = (sinTheta2*rho1 - sinTheta1*rho2) / det
    y = (cosTheta1*rho2 - cosTheta2*rho1) / det

    return (x, y)


def _find_centres(centreLines):
    horizontalLines, verticalLines = centreLines

    topLeftCentre = _intersection(horizontalLines[0], verticalLines[0])
    topMiddleCentre = _intersection(horizontalLines[0], verticalLines[1])
    topRightCentre = _intersection(horizontalLines[0], verticalLines[2])

    middleLeftCentre = _intersection(horizontalLines[1], verticalLines[0])
    middleCentre = _intersection(horizontalLines[1], verticalLines[1])
    middleRightCentre = _intersection(horizontalLines[1], verticalLines[2])

    bottomLeftCentre = _intersection(horizontalLines[2], verticalLines[0])
    bottomMiddleCentre = _intersection(horizontalLines[2], verticalLines[1])
    bottomRightCentre = _intersection(horizontalLines[2], verticalLines[2])

    return (
        topLeftCentre, topMiddleCentre, topRightCentre,
        middleLeftCentre, middleCentre, middleRightCentre,
        bottomLeftCentre, bottomMiddleCentre, bottomRightCentre
    )


def _draw_points(image, points):
    """Returns a copy of the image with the given points drawn on."""
    imageCopy = image.copy()
    for x, y in points:
        cv2.circle(imageCopy, (int(x), int(y)), 3, (255, 0, 255), -1)

    return imageCopy


def _colours_around_centre(image, centrePoint, offset):
    """Returns a list of colours in a square around a centre point"""
    centreX, centreY = centrePoint
    leftX = int(centreX) - offset
    rightX = int(centreX) + offset
    topY = int(centreY) - offset
    bottomY = int(centreY) + offset

    pixelColours = [
        image[y][x]
        for x in range(leftX, rightX + 1)
        for y in range(topY, bottomY + 1)
    ]

    return pixelColours


def _average_colour(colours):
    """Find the average of a list of colours."""
    bAverage = math.sqrt(sum(b**2 for b, _, _ in colours) / len(colours))
    gAverage = math.sqrt(sum(g**2 for _, g, _ in colours) / len(colours))
    rAverage = math.sqrt(sum(r**2 for _, _, r in colours) / len(colours))

    return (bAverage, gAverage, rAverage)


def _square_colours(image, centrePoints, offset=20):
    """Finds colour of each square using square around its centre point."""
    squareColours = tuple(
        _average_colour(_colours_around_centre(image, centrePoint, offset))
        for centrePoint in centrePoints
    )

    return squareColours


def _colour_similarity(colour1, colour2):
    """Returns the similarity between the colours from 0 (none) to 100 (the
    same).
    """
    b1, g1, r1 = colour1
    b2, g2, r2 = colour2

    diffBlue = abs(b1 - b2)
    diffGreen = abs(g1 - g2)
    diffRed = abs(r1 - r2)

    difference = (diffBlue + diffGreen + diffRed) / 3 / 255 * 100
    similarity = 100 - difference

    return similarity


class RubiksColour(enum.Enum):
    WHITE = 1,
    GREEN = 2,
    RED = 3,
    BLUE = 4,
    ORANGE = 5,
    YELLOW = 6


def _to_rubiks_colour(colour):
    """Returns the nearest rubiks cube colour to the given colour."""
    rubiksColours = [
        (RubiksColour.WHITE, (255., 255., 255.)),
        (RubiksColour.GREEN, (72., 155., 0.)),
        (RubiksColour.RED, (52., 18., 183.)),
        (RubiksColour.BLUE, (173., 70., 0.)),
        (RubiksColour.ORANGE, (0., 88., 255.)),
        (RubiksColour.YELLOW, (0., 213., 255.))
    ]

    similarities = [
        (rubiksColourName, _colour_similarity(colour, rubiksColour))
        for (rubiksColourName, rubiksColour) in rubiksColours
    ]

    similarities.sort(key=lambda similarity: similarity[1], reverse=True)

    return similarities[0][0]


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Scan colours from image of Rubik\'s Cube face'
    )
    parser.add_argument('image', help='Image file to scan')
    parser.add_argument('--edges', help='File to save edges image to')
    parser.add_argument('--lines', help='File to save lines image to')
    parser.add_argument(
        '--orth',
        help='File to save orthogonal lines image to'
    )
    parser.add_argument('--comb', help='File to save combined lines image to')
    parser.add_argument('--clines', help='File to save centre lines image to')
    parser.add_argument(
        '--cpoints',
        help='File to save centre points image to'
    )

    args = parser.parse_args()

    colours = scan_cube(
        cv2.imread(args.image),
        edgeImageFile=args.edges,
        linesImageFile=args.lines,
        orthogonalLinesImageFile=args.orth,
        combinedLinesImageFile=args.comb,
        centreLinesImageFile=args.clines,
        centrePointsImageFile=args.cpoints
    )

    print(colours)
